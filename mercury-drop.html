<!-- Imports polymer -->
<link rel="import" href="../polymer/polymer.html">

<style>
  .drop-hide {
    display: none !important;
  }

  .phantom-box {
    background-color: white;
    opacity: 0.8;
    border: 2px solid #6AF;
  }

  .drop-container {
    -webkit-user-select: none; /* Chrome/Safari */
    -moz-user-select: none; /* Firefox */
    -ms-user-select: none; /* IE10+ */
    -o-user-select: none;
    user-select: none;

    cursor: -webkit-grab;
    cursor: -moz-grab;
  }

  .drop-container.grabbing {
    cursor: -webkit-grabbing;
    cursor: -moz-grabbing;
  }

</style>
<!-- Defines element markup -->
<dom-module id="mercury-drop">
    <template>
      <div id="items" class="drop-container">
        <content></content>
      </div>
    </template>
</dom-module>

<!-- Registers custom element -->
<script>
Polymer({
    is: 'mercury-drop',

    properties: {
      items: {
        type: Array,
        notify: true
      },

      as: {
        type: String,
        value: 'item'
      }
    },

    coll: null,

    observers: [
      '_itemsChanged(items)'
    ],

    behaviors: [
      Polymer.Templatizer
    ],

    // Fires when an instance of the element is created
    created: function() {
      // console.log(this.items);
      this.templatize(Polymer.dom(this).querySelector('template'));
      Drop = this;
    },

    // Fires when the local DOM has been fully prepared
    ready: function() {

    },

    // Fires when the element was inserted into the document
    attached: function() {

    },

    // Fires when the element was removed from the document
    detached: function() {

    },

    listeners: {
      // 'down': 'handleDown',
      // 'up': 'handleUp'
      'track': 'handleMove'
    },

    moving: null,

    _getBox: function () {
      var box;

      box = document.createElement('div');
      box.style.height = this.elHeight + 'px';
      box.style.width = this.elWidht + 'px';
      box.className = 'phantom-box';

      return box;
    },

    _setInitHole: function (element) {
      var computed = window.getComputedStyle(element),
          last = false;

      this.elHeight = parseInt(computed.marginTop) + parseInt(computed.marginBottom) + element.offsetHeight;
      this.elWidth = parseInt(computed.marginRight) + parseInt(computed.marginLeft) + element.offsetWidth;
      this.computed = computed;

      this.hole = element.nextElementSibling;

      if (this.box) {
        this.box.remove();
      }

      if (this.hole) {
        this._setUpperBox(this.hole);
      }
      else {
        this._up = true;
        this.hole = element.previousElementSibling;
        this._setBottomBox(this.moving);
      }

      this.lastHover = this.hole;

      return last;
    },

    _setUpperBox: function (element) {
      this.box = this._getBox();

      // Polymer.dom(element.parentElement).insertBefore(box, element);
      element.insertAdjacentElement('beforebegin', this.box);
    },

    _setBottomBox: function (element) {
      this.box = this._getBox();

      // Polymer.dom(element.parentElement).insertAfter(box, element);
      element.insertAdjacentElement('afterend', this.box);
    },

    _removeBox: function () {
      if (this.box) {
        this.box.remove();
      }
    },

    _removeOffset: function (el) {
      if (el) {
        el.style.marginBottom = this.latestMarginBottom ? this.latestMarginBottom : '';
        el.style.marginTop = this.latestMarginTop ? this.latestMarginTop : '';
      }
    },

    _setUpperOffset: function (el) {
      if (el) {
        this.latestMarginTop = el.style.marginTop;
        el.style.marginTop = this.elHeight + 'px';
        this.hole = el;
      }
    },

    _setBottomOffset: function (el) {
      if (el) {
        this.latestMarginBottom = el.style.marginBottom;
        el.style.marginBottom = this.elHeight + 'px';
        this.hole = el;
      }
    },

    _initCoords: function (e) {
      this.initX = e.detail.x;
      this.initY = e.detail.y;
    },

    _setAbsolutePosition: function (el, last) {
      var x = el.offsetLeft - parseInt(this.computed.marginLeft),
          y = el.offsetTop - parseInt(this.computed.marginTop);

      this.oldPos = el.style.position;

      el.style.position = 'absolute';
      el.style.top = y + 'px';
      el.style.left = x + 'px';
    },

    _setPosition: function (el, e) {
      this.x = e.detail.x - this.initX;
      this.y = e.detail.y - this.initY;

      el.style.transform = 'translate3d(' + this.x + 'px, ' + this.y + 'px, 0)';
    },

    _getElementBehindCursor: function (el, e) {
        var state = el.className,
          hover;

      el.className += ' drop-hide';
      hover = e.detail.hover();

      while (!hover.attributes.draggable && hover.parentElement ) {
        hover = hover.parentElement;
      }

      el.className = state;

      return hover.attributes.draggable ? hover : null;
    },

    _changeMovingElement: function () {
      if (this.box) {
        var aftElement = this.box.nextElementSibling;
        if (aftElement && aftElement !== this.moving && this.moving !== this.box.previousElementSibling) {
          Polymer.dom(this).insertBefore(this.moving, aftElement);
        }
        else if (aftElement === this.moving || this.moving === this.box.previousElementSibling) {
          return;
        }
        else {
          Polymer.dom(this.$.items).appendChild(this.moving);
        }
      }
      Polymer.dom.flush();
    },

    _cleanItem: function () {
      this.moving.style.position = this.oldPosition || '';
      this.moving.style.top = '';
      this.moving.style.left = '';
      this.moving.style.transform = '';
    },

    _getNewItemsObject: function () {
      var els = this.$.items.children,
          len = els.length,
          it = [];

      for (var i = 0; i < len; i++) {
        if (els[i].attributes.draggable) {
          it.push(els[i]._templateInstance.item);
        }
      }

      this.items = it;
    },

    handleMove: function (e) {
      switch (e.detail.state) {
        case 'track':
          if (this._canMove) {
            this.hover = this._getElementBehindCursor(this.moving, e);
            this._setPosition(this.moving, e);
            if (this.hover) {
              var bound;

              if (this.hover !== this.lastHover) {
                bound = this.hover.getBoundingClientRect();
                this.hlimit = bound.top + (bound.height / 2);
              }

              var up = e.detail.y < this.hlimit;

              if ((this.hover !== this.hole || this._up !== up) ) {

                if (up) {
                  this._up = up;
                  this._removeBox();
                  this._setUpperBox(this.hover);
                }
                else {
                  this._up = up;
                  this._removeBox();
                  this._setBottomBox(this.hover);
                }

              }
              this.lastHover = this.hover;
            }
          }

          // console.log(e.detail.y, bound.top + (bound.height / 2));
          break;
        case 'start':
          this.moving = e.detail.hover();

          while (!this.moving.attributes.draggable && this.moving.parentElement ) {
            this.moving = this.moving.parentElement;
          }

          if (this.moving.attributes.draggable) {
            this._canMove = true;
            this.$.items.className += ' grabbing';
            var last = this._setInitHole(this.moving);
            this._setAbsolutePosition(this.moving, last);
            this._initCoords(e);
          }

          break;
        case 'end':
          if (this._canMove) {
            var className = this.$.items.className,
                pos = className.indexOf('grabbing');
            this.$.items.className = className.substr(0, pos) + className.substr(pos + 8, className.length);
            this._cleanItem();
            this._changeMovingElement();
            this._removeBox();
            this._canMove = false;
            this._getNewItemsObject();
          }
          break;
      }
    },

    handleDown: function (e) {
      window.addEventListener('mousemove', this.handleMove);
    },

    handleUp: function (e) {
      window.removeEventListener('mousemove', this.handleMove);
    },

    instances: [],

    _itemsChanged: function (items) {
      this.coll = Polymer.Collection.get(items);

      var childLen = this.$.items.children.length,
          itLen = items.length;

      for (var i = childLen; --i > 0;) {
        if (this.$.items.children[i].attributes.draggable) {
          Polymer.dom(this).removeChild(this.$.items.children[i]);
          Polymer.dom.flush();
        }
      }

      this.instances = [];

      for (var i = 0; i < itLen; i++) {
        this.templatize(Polymer.dom(this).querySelector('template'));
        var inst = this.stamp(null);
        this.instances.push(inst);
        Polymer.dom(this).appendChild(inst.root);
      }

      this.debounce('refresh', this._insertItems);
    },

    _insertItems: function () {
      var items = this.items;
      for (var i = 0; i < items.length; i++) {
        var element = this.instances[i];
        element[this.as] = items[i];
      }

    },

    // Fires when an attribute was added, removed, or updated
    attributeChanged: function(attr, oldVal, newVal) {}
});
</script>
